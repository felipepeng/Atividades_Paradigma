Atividade 1:

1.
i = 1
while i <= 10:
    print(i)
    i += 1


2.
for i in range(1, 11):
    print(i)


3.
O código original com goto é funcional, mas pouco legível, pois exige que o leitor acompanhe manualmente os saltos entre os rótulos (goto loop, goto check).
A versão com while já melhora a leitura, pois deixa claro que haverá repetição enquanto a condição for verdadeira.
A versão com for é a mais simples e legível nesse caso, pois expressa de forma concisa que i percorre uma sequência de valores de 1 a 10, sem precisar gerenciar manualmente o incremento ou a condição de parada.

========================================================================

Atividade 2:

1.
#include <stdio.h>

int main() {
    int opcao, n, i, fatorial;

    do {
        printf("\nMenu:\n");
        printf("1. Calcular quadrado\n");
        printf("2. Calcular fatorial\n");
        printf("3. Sair\n");
        printf("Escolha uma opcao: ");
        scanf("%d", &opcao);

        switch(opcao) {
            case 1:
                printf("Digite um numero: ");
                scanf("%d", &n);
                printf("Quadrado: %d\n", n * n);
                break;

            case 2:
                printf("Digite um numero: ");
                scanf("%d", &n);
                fatorial = 1;
                for(i = 1; i <= n; i++)
                    fatorial *= i;
                printf("Fatorial: %d\n", fatorial);
                break;

            case 3:
                printf("Saindo...\n");
                break;

            default:
                printf("Opcao invalida!\n");
        }
    } while(opcao != 3);

    return 0;
}


2.
while True:
    print("\nMenu:")
    print("1. Calcular quadrado")
    print("2. Calcular fatorial")
    print("3. Sair")
    opcao = int(input("Escolha uma opcao: "))

    if opcao == 1:
        n = int(input("Digite um numero: "))
        print(f"Quadrado: {n * n}")
    elif opcao == 2:
        n = int(input("Digite um numero: "))
        fatorial = 1
        for i in range(1, n + 1):
            fatorial *= i
        print(f"Fatorial: {fatorial}")
    elif opcao == 3:
        print("Saindo...")
        break
    else:
        print("Opcao invalida!")


3.
A versão em C é mais verbosa, pois exige switch/case, declaração de variáveis no início e controle manual da repetição com do/while.
Em Python, o código é mais enxuto, pois não precisa declarar variáveis antecipadamente e a sintaxe é mais próxima da linguagem natural.


4.
A implementação em Python é mais simples e rápida de escrever, pois exige menos código e tem sintaxe mais clara. Além disso, não é necessário declarar tipos de variáveis, o que torna o desenvolvimento mais ágil.

======================================================

Atividade 3:

1.
def processar_lista(lista):
    for numero in lista:
        if numero == 0:
            print("Encontrado 0, parando execução.")
            break
        if numero < 0:
            continue
        if numero % 2 == 0:
            return numero * 2
    return None  # caso não haja nenhum número par

# Exemplo de uso
lista = [5, -3, 7, -2, 8, 4]
resultado = processar_lista(lista)
if resultado:
    print("Dobro do primeiro par encontrado:", resultado)
else:
    print("Nenhum número par encontrado.")


2.
Se fosse usado goto, precisaríamos de vários rótulos para simular break, continue e return. O código ficaria confuso, com saltos espalhados, dificultando a leitura e manutenção.
A abordagem moderna com break, continue e return é mais clara e estruturada, permitindo entender o fluxo de execução rapidamente sem precisar "caçar" rótulos no código.
