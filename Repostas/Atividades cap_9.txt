Exercício 1:

Código em C:
#include <stdio.h>

// --- Função por valor ---
void dobrarPorValor(int x) {
    x = x * 2;
}

// --- Função por referência (ponteiro) ---
void dobrarPorReferencia(int *x) {
    *x = *x * 2;
}

int main() {
    int numero = 10;

    printf("Valor inicial: %d\n", numero);

    // Passagem por valor
    dobrarPorValor(numero);
    printf("Depois de dobrar (por valor): %d\n", numero);

    // Passagem por referência
    dobrarPorReferencia(&numero);
    printf("Depois de dobrar (por referência): %d\n", numero);

    return 0;
}


Questões:
Qual a diferença observada entre as duas versões?
Na versão por valor, o número não muda fora da função. Na versão por referência, o valor é alterado na variável original.

Por que o valor da variável só se altera na versão por referência?
Na passagem por valor, é feita uma cópia da variável — a função altera apenas a cópia local. Na passagem por referência, a função recebe o endereço da variável original e altera diretamente seu conteúdo.

Relação com as estratégias de passgem de parâmetros:
Isso ilustra as estratégias de passagem por valor (segura, mas sem efeito colateral) e passagem por referência (permite que o subprograma modifique o argumento).

------------------------------------------------------------------
Exercício 2:

Questões:
O que acontece com a ordem das mensagens?
Elas se intercalam de forma não determinística — às vezes a corrotina imprime primeiro, às vezes a função normal.

Por que isso acontece?
Porque a corrotina é executada concorrentemente com a função principal — o escalonador do Go alterna entre elas, resultando em interleaving das mensagens.

Relação com o conceito de corrotinas:
Corrotinas são rotinas que podem pausar e retomar execução, permitindo concorrência cooperativa ou preemptiva. No Go, go inicia a função como uma goroutine, que roda em paralelo ao fluxo principal. Isso permite que várias tarefas sejam executadas de forma concorrente sem bloquear umas às outras.